package video

/*
#cgo LDFLAGS: -lx264
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <x264.h>

// --- C TARAFI: HIZLI DOWNSCALE + YUV DÃ–NÃœÅÃœMÃœ (ORÄ°JÄ°NAL - DOKUNULMADI) ---
static void rgba_to_yuv420_scaled(uint8_t *rgba, uint8_t *y_plane, uint8_t *u_plane, uint8_t *v_plane, 
                                  int in_w, int in_h, int out_w, int out_h, int stride) {
    
    int uv_index = 0;
    int y_index = 0;

    for (int j = 0; j < out_h; j++) {
        int src_y = (j * in_h) / out_h;
        uint8_t *row_start = rgba + (src_y * stride);

        for (int i = 0; i < out_w; i++) {
            int src_x = (i * in_w) / out_w;
            int offset = src_x * 4; 

            uint8_t b = row_start[offset + 0];
            uint8_t g = row_start[offset + 1];
            uint8_t r = row_start[offset + 2];

            int y_val = ((66 * r + 129 * g + 25 * b + 128) >> 8) + 16;
            y_plane[y_index++] = (uint8_t)(y_val < 0 ? 0 : (y_val > 255 ? 255 : y_val));

            if ((j % 2) == 0 && (i % 2) == 0) {
                int u_val = ((-38 * r - 74 * g + 112 * b + 128) >> 8) + 128;
                int v_val = ((112 * r - 94 * g - 18 * b + 128) >> 8) + 128;

                u_plane[uv_index] = (uint8_t)(u_val < 0 ? 0 : (u_val > 255 ? 255 : u_val));
                v_plane[uv_index] = (uint8_t)(v_val < 0 ? 0 : (v_val > 255 ? 255 : v_val));
                uv_index++;
            }
        }
    }
}

static x264_t* init_encoder(int width, int height, int fps, x264_param_t* param) {
    // PRESET: 'superfast' + 'zerolatency'
    // 'ultrafast' yerine 'superfast' kullanarak aynÄ± bitrate'te daha net gÃ¶rÃ¼ntÃ¼ alÄ±yoruz.
    if (x264_param_default_preset(param, "superfast", "zerolatency") < 0) {
        return NULL;
    }

    param->i_width  = width;
    param->i_height = height;
    
    // ğŸ”¥ FPS KÄ°LÄ°DÄ°: 25 FPS (AltÄ±n Oran)
    // Bant geniÅŸliÄŸini %17 rahatlatÄ±r, akÄ±cÄ±lÄ±k kaybÄ± minimumdur.
    param->i_fps_num = 25; 
    param->i_fps_den = 1;
    
    // Intra Refresh: DonmalarÄ± yumuÅŸatÄ±r, ani veri yÃ¼kÃ¼nÃ¼ engeller.
    param->b_intra_refresh = 1;
    
    // Keyframe SÄ±klÄ±ÄŸÄ±: 1 saniyede toparlanma (FPS=25 olduÄŸu iÃ§in)
    param->i_keyint_max = 25;      
    param->i_keyint_min = 12; 

    // ğŸ”¥ MTU GÃœVENLÄ°ÄÄ°: 1000 Byte
    // VPN tÃ¼nelinde (Ã¶zellikle Router engellerine karÅŸÄ±) en gÃ¼venli boyut.
    param->i_slice_max_size = 1000; 

    // ğŸ”¥ AGRESIF RATE CONTROL (1080p iÃ§in)
    // 1080p gÃ¶rÃ¼ntÃ¼yÃ¼ 2500kbps'e sÄ±ÄŸdÄ±rÄ±yoruz. 
    // Metinler keskin kalÄ±r, Router "SaldÄ±rÄ± var" sanÄ±p baÄŸlantÄ±yÄ± kesmez.
    param->rc.i_rc_method = X264_RC_ABR;
    param->rc.i_bitrate = 1800;          // Hedef: 2500 kbps
    param->rc.i_vbv_max_bitrate = 2000;  // Tavan: 3000 kbps (Asla geÃ§me)
    param->rc.i_vbv_buffer_size = 1000;  // Tampon: 1.5 saniyelik veri

    // SÄ±kÄ±ÅŸtÄ±rma limitleri (GÃ¶rÃ¼ntÃ¼ Ã§ok karmaÅŸÄ±ksa kaliteyi dÃ¼ÅŸÃ¼r ama donma)
    param->rc.i_qp_min = 20; 
    param->rc.i_qp_max = 51;

    param->b_repeat_headers = 1;
    param->b_annexb = 1;
    x264_param_apply_profile(param, "baseline"); 
    param->i_log_level = X264_LOG_NONE;

    return x264_encoder_open(param);
}
*/
import "C"

import (
	"errors"
	"image"
	"unsafe"
)

type Encoder struct {
	InWidth, InHeight   int
	OutWidth, OutHeight int
	FPS                 int

	handle *C.x264_t
	param  C.x264_param_t
	picIn  C.x264_picture_t
	picOut C.x264_picture_t

	frameIndex int64
}

// NewEncoder: Ã‡Ã¶zÃ¼nÃ¼rlÃ¼k ayarlarÄ±
func NewEncoder(inW, inH, outW, outH, fps int) (*Encoder, error) {
	if outW == 0 || outH == 0 {
		outW, outH = inW, inH
	}

	// x264 Ã§ift sayÄ± sever
	if outW%2 != 0 { outW-- }
	if outH%2 != 0 { outH-- }

	e := &Encoder{
		InWidth:   inW,
		InHeight:  inH,
		OutWidth:  outW,
		OutHeight: outH,
		FPS:       fps,
	}

	// Encoder hedef Ã§Ã¶zÃ¼nÃ¼rlÃ¼kle baÅŸlatÄ±lÄ±r
	e.handle = C.init_encoder(C.int(outW), C.int(outH), C.int(fps), &e.param)
	if e.handle == nil {
		return nil, errors.New("x264 baÅŸlatÄ±lamadÄ±")
	}

	// Resim belleÄŸi
	C.x264_picture_alloc(&e.picIn, C.X264_CSP_I420, C.int(outW), C.int(outH))

	return e, nil
}

func (e *Encoder) Encode(img *image.RGBA) []byte {
	if img == nil || e.handle == nil {
		return nil
	}

	srcPtr := unsafe.Pointer(&img.Pix[0])
	yPtr := unsafe.Pointer(e.picIn.img.plane[0])
	uPtr := unsafe.Pointer(e.picIn.img.plane[1])
	vPtr := unsafe.Pointer(e.picIn.img.plane[2])

	// C tarafÄ±ndaki fonksiyon Ã§aÄŸrÄ±sÄ± (Aynen korundu)
	C.rgba_to_yuv420_scaled(
		(*C.uint8_t)(srcPtr),
		(*C.uint8_t)(yPtr),
		(*C.uint8_t)(uPtr),
		(*C.uint8_t)(vPtr),
		C.int(e.InWidth),   
		C.int(e.InHeight),
		C.int(e.OutWidth),  
		C.int(e.OutHeight),
		C.int(img.Stride),
	)

	e.picIn.i_pts = C.int64_t(e.frameIndex)
	e.frameIndex++

	var nals *C.x264_nal_t
	var iNals C.int

	frameSize := C.x264_encoder_encode(e.handle, &nals, &iNals, &e.picIn, &e.picOut)
	if frameSize <= 0 {
		return nil
	}

	nalSlice := unsafe.Slice(nals, int(iNals))
	return C.GoBytes(unsafe.Pointer(nalSlice[0].p_payload), C.int(frameSize))
}

func (e *Encoder) Close() {
	if e.handle != nil {
		C.x264_encoder_close(e.handle)
		C.x264_picture_clean(&e.picIn)
		e.handle = nil
	}
}